// Parse event/log data based on the 'seaport' ABI
//
// Code generated by "genabi"; DO NOT EDIT.
package seaport

import (
	"github.com/indexsupply/x/abi"
	"github.com/indexsupply/x/abi/schema"
	"math/big"
)

type CounterIncremented struct {
	item *abi.Item

	// Indexed:
	Offerer [20]byte
	// Un-indexed:
	NewCounter *big.Int
}

func (x CounterIncremented) Done() {
	x.item.Done()
}

func decodeCounterIncremented(item *abi.Item) CounterIncremented {
	x := CounterIncremented{}
	x.NewCounter = item.At(0).BigInt()
	return x
}

var (
	counterIncrementedSignature = [32]byte{0x72, 0x1c, 0x20, 0x12, 0x12, 0x97, 0x51, 0x2b, 0x72, 0x82, 0x1b, 0x97, 0xf5, 0x32, 0x68, 0x77, 0xea, 0x8e, 0xcf, 0x4b, 0xb9, 0x94, 0x8f, 0xea, 0x5b, 0xfc, 0xb6, 0x45, 0x30, 0x74, 0xd3, 0x7f}
	counterIncrementedSchema    = schema.Parse("(uint256)")
)

// Event Signature:
//	CounterIncremented(uint256,address)
// Checks the first log topic against the signature hash:
//	721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f
//
// Copies indexed event inputs from the remaining topics
// into [CounterIncremented]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [CounterIncremented]:
//	(uint256)
func MatchCounterIncremented(l abi.Log) (CounterIncremented, bool) {
	if len(l.Topics) > 0 && counterIncrementedSignature != l.Topics[0] {
		return CounterIncremented{}, false
	}
	_, item := abi.Decode(l.Data, counterIncrementedSchema)
	res := decodeCounterIncremented(item)
	res.item = item
	res.Offerer = abi.Bytes(l.Topics[1][:]).Address()
	return res, true
}

type OrderCancelled struct {
	item *abi.Item

	// Indexed:
	Offerer [20]byte
	Zone    [20]byte
	// Un-indexed:
	OrderHash [32]byte
}

func (x OrderCancelled) Done() {
	x.item.Done()
}

func decodeOrderCancelled(item *abi.Item) OrderCancelled {
	x := OrderCancelled{}
	x.OrderHash = item.At(0).Bytes32()
	return x
}

var (
	orderCancelledSignature = [32]byte{0x6b, 0xac, 0xc0, 0x1d, 0xbe, 0x44, 0x24, 0x96, 0x6, 0x8f, 0x7d, 0x23, 0x4e, 0xdd, 0x81, 0x1f, 0x1a, 0x5f, 0x83, 0x32, 0x43, 0xe0, 0xae, 0xc8, 0x24, 0xf8, 0x6a, 0xb8, 0x61, 0xf3, 0xc9, 0xd}
	orderCancelledSchema    = schema.Parse("(bytes32)")
)

// Event Signature:
//	OrderCancelled(bytes32,address,address)
// Checks the first log topic against the signature hash:
//	6bacc01dbe442496068f7d234edd811f1a5f833243e0aec824f86ab861f3c90d
//
// Copies indexed event inputs from the remaining topics
// into [OrderCancelled]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [OrderCancelled]:
//	(bytes32)
func MatchOrderCancelled(l abi.Log) (OrderCancelled, bool) {
	if len(l.Topics) > 0 && orderCancelledSignature != l.Topics[0] {
		return OrderCancelled{}, false
	}
	_, item := abi.Decode(l.Data, orderCancelledSchema)
	res := decodeOrderCancelled(item)
	res.item = item
	res.Offerer = abi.Bytes(l.Topics[1][:]).Address()
	res.Zone = abi.Bytes(l.Topics[2][:]).Address()
	return res, true
}

type OrderFulfilled struct {
	item *abi.Item

	// Indexed:
	Offerer [20]byte
	Zone    [20]byte
	// Un-indexed:
	OrderHash     [32]byte
	Recipient     [20]byte
	Offer         []Offer
	Consideration []Consideration
}

func (x OrderFulfilled) Done() {
	x.item.Done()
}

func decodeOrderFulfilled(item *abi.Item) OrderFulfilled {
	x := OrderFulfilled{}
	x.OrderHash = item.At(0).Bytes32()
	x.Recipient = item.At(1).Address()
	offerItem0 := item.At(2)
	offer0 := make([]Offer, offerItem0.Len())
	for i0 := 0; i0 < offerItem0.Len(); i0++ {
		offer0[i0] = decodeOffer(offerItem0.At(i0))
	}
	x.Offer = offer0
	considerationItem0 := item.At(3)
	consideration0 := make([]Consideration, considerationItem0.Len())
	for i0 := 0; i0 < considerationItem0.Len(); i0++ {
		consideration0[i0] = decodeConsideration(considerationItem0.At(i0))
	}
	x.Consideration = consideration0
	return x
}

type Offer struct {
	item *abi.Item

	// Un-indexed:
	ItemType   uint8
	Token      [20]byte
	Identifier *big.Int
	Amount     *big.Int
}

func (x Offer) Done() {
	x.item.Done()
}

func decodeOffer(item *abi.Item) Offer {
	x := Offer{}
	x.ItemType = item.At(0).Uint8()
	x.Token = item.At(1).Address()
	x.Identifier = item.At(2).BigInt()
	x.Amount = item.At(3).BigInt()
	return x
}

type Consideration struct {
	item *abi.Item

	// Un-indexed:
	ItemType   uint8
	Token      [20]byte
	Identifier *big.Int
	Amount     *big.Int
	Recipient  [20]byte
}

func (x Consideration) Done() {
	x.item.Done()
}

func decodeConsideration(item *abi.Item) Consideration {
	x := Consideration{}
	x.ItemType = item.At(0).Uint8()
	x.Token = item.At(1).Address()
	x.Identifier = item.At(2).BigInt()
	x.Amount = item.At(3).BigInt()
	x.Recipient = item.At(4).Address()
	return x
}

var (
	orderFulfilledSignature = [32]byte{0x9d, 0x9a, 0xf8, 0xe3, 0x8d, 0x66, 0xc6, 0x2e, 0x2c, 0x12, 0xf0, 0x22, 0x52, 0x49, 0xfd, 0x9d, 0x72, 0x1c, 0x54, 0xb8, 0x3f, 0x48, 0xd9, 0x35, 0x2c, 0x97, 0xc6, 0xca, 0xcd, 0xcb, 0x6f, 0x31}
	orderFulfilledSchema    = schema.Parse("(bytes32,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])")
)

// Event Signature:
//	OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])
// Checks the first log topic against the signature hash:
//	9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31
//
// Copies indexed event inputs from the remaining topics
// into [OrderFulfilled]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [OrderFulfilled]:
//	(bytes32,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])
func MatchOrderFulfilled(l abi.Log) (OrderFulfilled, bool) {
	if len(l.Topics) > 0 && orderFulfilledSignature != l.Topics[0] {
		return OrderFulfilled{}, false
	}
	_, item := abi.Decode(l.Data, orderFulfilledSchema)
	res := decodeOrderFulfilled(item)
	res.item = item
	res.Offerer = abi.Bytes(l.Topics[1][:]).Address()
	res.Zone = abi.Bytes(l.Topics[2][:]).Address()
	return res, true
}

type OrderValidated struct {
	item *abi.Item

	// Un-indexed:
	OrderHash       [32]byte
	OrderParameters OrderParameters
}

func (x OrderValidated) Done() {
	x.item.Done()
}

func decodeOrderValidated(item *abi.Item) OrderValidated {
	x := OrderValidated{}
	x.OrderHash = item.At(0).Bytes32()
	x.OrderParameters = decodeOrderParameters(item.At(1))
	return x
}

type OrderParameters struct {
	item *abi.Item

	// Un-indexed:
	Offerer                         [20]byte
	Zone                            [20]byte
	Offer                           []Offer
	Consideration                   []Consideration
	OrderType                       uint8
	StartTime                       *big.Int
	EndTime                         *big.Int
	ZoneHash                        [32]byte
	Salt                            *big.Int
	ConduitKey                      [32]byte
	TotalOriginalConsiderationItems *big.Int
}

func (x OrderParameters) Done() {
	x.item.Done()
}

func decodeOrderParameters(item *abi.Item) OrderParameters {
	x := OrderParameters{}
	x.Offerer = item.At(0).Address()
	x.Zone = item.At(1).Address()
	offerItem0 := item.At(2)
	offer0 := make([]Offer, offerItem0.Len())
	for i0 := 0; i0 < offerItem0.Len(); i0++ {
		offer0[i0] = decodeOffer(offerItem0.At(i0))
	}
	x.Offer = offer0
	considerationItem0 := item.At(3)
	consideration0 := make([]Consideration, considerationItem0.Len())
	for i0 := 0; i0 < considerationItem0.Len(); i0++ {
		consideration0[i0] = decodeConsideration(considerationItem0.At(i0))
	}
	x.Consideration = consideration0
	x.OrderType = item.At(4).Uint8()
	x.StartTime = item.At(5).BigInt()
	x.EndTime = item.At(6).BigInt()
	x.ZoneHash = item.At(7).Bytes32()
	x.Salt = item.At(8).BigInt()
	x.ConduitKey = item.At(9).Bytes32()
	x.TotalOriginalConsiderationItems = item.At(10).BigInt()
	return x
}

var (
	orderValidatedSignature = [32]byte{0xf2, 0x80, 0x79, 0x1e, 0xfe, 0x78, 0x2e, 0xdc, 0xf0, 0x6c, 0xe1, 0x5c, 0x8f, 0x4d, 0xff, 0x17, 0x60, 0x1d, 0xb3, 0xb8, 0x8e, 0xb3, 0x80, 0x5a, 0xd, 0xb7, 0xd7, 0x7f, 0xaf, 0x75, 0x7f, 0x4}
	orderValidatedSchema    = schema.Parse("(bytes32,(address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))")
)

// Event Signature:
//	OrderValidated(bytes32,(address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))
// Checks the first log topic against the signature hash:
//	f280791efe782edcf06ce15c8f4dff17601db3b88eb3805a0db7d77faf757f04
//
// Copies indexed event inputs from the remaining topics
// into [OrderValidated]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [OrderValidated]:
//	(bytes32,(address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))
func MatchOrderValidated(l abi.Log) (OrderValidated, bool) {
	if len(l.Topics) > 0 && orderValidatedSignature != l.Topics[0] {
		return OrderValidated{}, false
	}
	_, item := abi.Decode(l.Data, orderValidatedSchema)
	res := decodeOrderValidated(item)
	res.item = item
	return res, true
}

type OrdersMatched struct {
	item *abi.Item

	// Un-indexed:
	OrderHashes [][32]byte
}

func (x OrdersMatched) Done() {
	x.item.Done()
}

func decodeOrdersMatched(item *abi.Item) OrdersMatched {
	x := OrdersMatched{}
	orderHashesItem0 := item.At(0)
	orderHashes0 := make([][32]byte, orderHashesItem0.Len())
	for i0 := 0; i0 < orderHashesItem0.Len(); i0++ {
		orderHashes0[i0] = orderHashesItem0.Bytes32()
	}
	x.OrderHashes = orderHashes0
	return x
}

var (
	ordersMatchedSignature = [32]byte{0x4b, 0x9f, 0x2d, 0x36, 0xe1, 0xb4, 0xc9, 0x3d, 0xe6, 0x2c, 0xc0, 0x77, 0xb0, 0xb, 0x1a, 0x91, 0xd8, 0x4b, 0x6c, 0x31, 0xb4, 0xa1, 0x4e, 0x1, 0x27, 0x18, 0xdc, 0xca, 0x23, 0x6, 0x89, 0xe7}
	ordersMatchedSchema    = schema.Parse("(bytes32[])")
)

// Event Signature:
//	OrdersMatched(bytes32[])
// Checks the first log topic against the signature hash:
//	4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7
//
// Copies indexed event inputs from the remaining topics
// into [OrdersMatched]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [OrdersMatched]:
//	(bytes32[])
func MatchOrdersMatched(l abi.Log) (OrdersMatched, bool) {
	if len(l.Topics) > 0 && ordersMatchedSignature != l.Topics[0] {
		return OrdersMatched{}, false
	}
	_, item := abi.Decode(l.Data, ordersMatchedSchema)
	res := decodeOrdersMatched(item)
	res.item = item
	return res, true
}
